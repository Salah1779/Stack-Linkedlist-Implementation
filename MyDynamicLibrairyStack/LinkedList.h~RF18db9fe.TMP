#pragma once

#include <iostream>
#include "Node.h"
using namespace std;



template <class MyType>
class LinkedList {
private:
    Node* head;

public:
    LinkedList();
    void append(MyType val);
    void clear();
    ~LinkedList();
    void insertHead(MyType val);
    void deleteHead(MyType* deleted);
    bool isEmpty() const;

};
    


template<class MyType>
inline LinkedList<MyType>::LinkedList()
{
    head = nullptr;
}

template<class MyType>
inline void LinkedList<MyType>::append(MyType val)
{
    Node* newNode = new Node(val);
    if (head == nullptr) {
        head = newNode;
    }
    else {
        Node* temp = head;
        while (temp->next != nullptr) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
}


template<class MyType>
inline void LinkedList<MyType>::clear()
{
    Node* current = head;
    while (current != nullptr) {
        Node* nextNode = current->next;
        delete current;
        current = nextNode;
    }
    head = nullptr;
}

template<class MyType>
inline LinkedList<MyType>::~LinkedList()
{
    clear();
}

template<class MyType>
inline void LinkedList<MyType>::insertHead(MyType e)
{
    Node * newNode =new Node(e)
    if (head == nullptr)
        head = newNode;
    else {
        newNode->next = head;
        head = newNode;
    }

}

template<class MyType>
inline void LinkedList<MyType>::deleteHead(MyType * deleted)
{   
    Node* tmp = head;
    *deleted = tmp->getVal();
    head = tmp->next;
    delete tmp;
}

template<class MyType>
inline bool LinkedList<MyType>::isEmpty() const
{
    return head==nullptr;
}



